#!/usr/bin/env node
/* -*- indent-tabs-mode: nil -*- */
'use strict';

var _ = require('lodash');
var promisify = require('promisify-node');
var fs = promisify('graceful-fs');
var path = promisify(require('path'));
var process = require('process');
var rimraf = promisify('rimraf');

// Reusable rimraf options. Globbing is eeeevil because it makes
// things way more dangerous!
var fsNoGlob = Object.assign({}, require('graceful-fs'), {glob: false,});

var requireSemverPackageJson = require('../package.json');

var uniqueName;
{
    let uniqueId = 0;
    uniqueName = friendly => `u${++uniqueId}-${friendly}`;
}

var gather = function (rootDirPath, dirPath) {
    // Scan the directory for modules.
    return fs.readdir(dirPath).then(function (dirEnts) {
        return Promise.all(dirEnts.map(dirEnt => {
            // Skip, e.g., .bin/
            if (/^\./.test(dirEnt)) {
                return [];
            }
            // Load metadata for found modules.
            let packagePath = path.join(dirPath, dirEnt);
            // Gather nested modules first (before we call rename()
            // later).
            let subDirPath = path.join(packagePath, 'node_modules');
            return fs.access(subDirPath).then(() => {
                return gather(rootDirPath, subDirPath);
            }, () => {
                return [];
            }).then(infos => fs.readFile(path.join(packagePath, 'package.json')).then(packageJsonString => {
                let packageJson = JSON.parse(packageJsonString);

                // Validate up front as much as possible.
                if (!packageJson.name) {
                    throw new Error(`${packagePath} missing name key`);
                }
                if (!packageJson.version) {
                    throw new Error(`${packagePath} missing version key`);
                }

                // Rename them out of the way.
                let temporaryPackagePath = path.join(rootDirPath, uniqueName(`${packageJson.name}-${packageJson.version}`));
                return fs.rename(packagePath, temporaryPackagePath).then(() => {
                    // Save data for post-analysis stage.
                    infos.push(
                        {
                            packageJson: packageJson,
                            temporaryPackagePath: temporaryPackagePath,
                        });
                    return infos;
                });
            }));
        })).then(x => _.flatten(x));
    });
};

var fixDir = function (dirPath, requireSemverPath) {
    return gather(dirPath, dirPath).then(infos => {
        // Create base directory for each package.
        return Promise.all(
            _.uniqBy(infos, _.property(['packageJson', 'name', ])).map(info => {
                let packagePath = path.join('node_modules', info.packageJson.name);
                // Create the stub module
                return fs.mkdir(packagePath).then(() => {
                    return Promise.all([
                        fs.writeFile(
                            path.join(packagePath, 'package.json'),
                            JSON.stringify(
                                {
                                    main: 'main.js',
                                })),
                        fs.writeFile(
                            path.join(packagePath, 'main.js'),
                            `// This file is generated by ${requireSemverPackageJson.name}.
// It is a stub which delegates to a semver-sensitive require()
// implementation.
'use strict';
module.exports = require(${JSON.stringify(`${requireSemverPackageJson.name}/${requireSemverPackageJson.version}`)})(module, ${JSON.stringify(info.packageJson.name)});
`)]);
                    return info;
                });
            })).then(() => {
                let satisfiedVersions = {};
                return Promise.all(infos.map(info => {
                    let packagePath = path.join('node_modules', info.packageJson.name);
                    let packageVersionPath = path.join(packagePath, info.packageJson.version);
                    if (satisfiedVersions[packageVersionPath]) {
                        // Only satisfy each version once. Drop
                        // duplicates by deleting them.
                        console.log(`Found duplicate ${info.packageJson.name}-${info.packageJson.version}`);
                        return rimraf(info.temporaryPackagePath, fsNoGlob);
                    }
                    satisfiedVersions[packageVersionPath] = true;
                    return fs.rename(info.temporaryPackagePath, packageVersionPath);
                }));
            });
    });
};

fixDir('node_modules').then(() => {
    console.log('Done!');
}, e => {
    console.error(e, e.stack); // http://stackoverflow.com/a/15699740/429091
    process.exit(1);
});
